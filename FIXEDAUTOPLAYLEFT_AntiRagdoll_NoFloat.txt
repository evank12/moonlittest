
repeat task.wait() until game:IsLoaded()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer

local function waitForCharacter()
    local char = Player.Character
    if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChildOfClass("Humanoid") then
        return char
    end
    return Player.CharacterAdded:Wait()
end
task.spawn(function() waitForCharacter() end)

if not getgenv then getgenv = function() return _G end end

local ConfigFileName = "MOONLIT_DUELS_Config.json"
local Enabled = {
    SpeedBoost = false,
    SpinBot = false,
    SpeedWhileStealing = false,
    AutoSteal = false,
    Unwalk = false,
    Optimizer = false,
    SpamBat = false,
    BatAimbot = false,
    AutoWalkEnabled = false,
    AutoRightEnabled = false,
    LowGravity = false,
    MiniJump = false,
    AutoLeftReturn = false,
    Dodge = false,
    AntiRagdoll = false,
    Float = false
}
local Values = {
    BoostSpeed = 59,
    SpinSpeed = 30,
    StealingSpeedValue = 29,
    STEAL_RADIUS = 58,
    STEAL_DURATION = 1.3,
    DEFAULT_GRAVITY = 196.2,
    GalaxyGravityPercent = 70,
    HOP_POWER = 35,
    HOP_COOLDOWN = 0.08
}
local KEYBINDS = {
    SPEED = Enum.KeyCode.V,
    SPIN = Enum.KeyCode.T,
    BATAIMBOT = Enum.KeyCode.X,
    NUKE = Enum.KeyCode.Q,
    AUTOLEFT = Enum.KeyCode.Z,
    AUTORIGHT = Enum.KeyCode.C,
    LOWGRAVITY = Enum.KeyCode.M,
    MINIJUMP = Enum.KeyCode.N,
    AUTOLEFTRETURN = Enum.KeyCode.F,
    DODGE = Enum.KeyCode.LeftAlt,
    FLOAT = Enum.KeyCode.G
}

local configLoaded = false
pcall(function()
    if readfile and isfile and isfile(ConfigFileName) then
        local data = HttpService:JSONDecode(readfile(ConfigFileName))
        if data then
            for k, v in pairs(data) do
                if Enabled[k] ~= nil then Enabled[k] = v end
                if Values[k] ~= nil then Values[k] = v end
            end
            if data.KEY_SPEED then KEYBINDS.SPEED = Enum.KeyCode[data.KEY_SPEED] end
            if data.KEY_SPIN then KEYBINDS.SPIN = Enum.KeyCode[data.KEY_SPIN] end
            if data.KEY_BATAIMBOT then KEYBINDS.BATAIMBOT = Enum.KeyCode[data.KEY_BATAIMBOT] end
            if data.KEY_AUTOLEFT then KEYBINDS.AUTOLEFT = Enum.KeyCode[data.KEY_AUTOLEFT] end
            if data.KEY_AUTORIGHT then KEYBINDS.AUTORIGHT = Enum.KeyCode[data.KEY_AUTORIGHT] end
            if data.KEY_LOWGRAVITY then KEYBINDS.LOWGRAVITY = Enum.KeyCode[data.KEY_LOWGRAVITY] end
            if data.KEY_MINIJUMP then KEYBINDS.MINIJUMP = Enum.KeyCode[data.KEY_MINIJUMP] end
            if data.KEY_AUTOLEFTRETURN then KEYBINDS.AUTOLEFTRETURN = Enum.KeyCode[data.KEY_AUTOLEFTRETURN] end
            if data.KEY_DODGE then KEYBINDS.DODGE = Enum.KeyCode[data.KEY_DODGE] end
            if data.KEY_FLOAT then KEYBINDS.FLOAT = Enum.KeyCode[data.KEY_FLOAT] end
            configLoaded = true
        end
    end
end)

local function SaveConfig()
    local data = {}
    for k, v in pairs(Enabled) do data[k] = v end
    for k, v in pairs(Values) do data[k] = v end
    data.KEY_SPEED = KEYBINDS.SPEED.Name
    data.KEY_SPIN = KEYBINDS.SPIN.Name
    data.KEY_BATAIMBOT = KEYBINDS.BATAIMBOT.Name
    data.KEY_AUTOLEFT = KEYBINDS.AUTOLEFT.Name
    data.KEY_AUTORIGHT = KEYBINDS.AUTORIGHT.Name
    data.KEY_LOWGRAVITY = KEYBINDS.LOWGRAVITY.Name
    data.KEY_MINIJUMP = KEYBINDS.MINIJUMP.Name
    data.KEY_AUTOLEFTRETURN = KEYBINDS.AUTOLEFTRETURN.Name
    data.KEY_DODGE = KEYBINDS.DODGE.Name
    data.KEY_FLOAT = KEYBINDS.FLOAT.Name

    if not writefile then return false end
    local ok = pcall(function()
        writefile(ConfigFileName, HttpService:JSONEncode(data))
    end)
    return ok
end

local Connections = {}
local isStealing = false
local lastBatSwing = 0
local BAT_SWING_COOLDOWN = 0.12
local SlapList = {
    {1, "Bat"}, {2, "Slap"}, {3, "Iron Slap"}, {4, "Gold Slap"},
    {5, "Diamond Slap"}, {6, "Emerald Slap"}, {7, "Ruby Slap"},
    {8, "Dark Matter Slap"}, {9, "Flame Slap"}, {10, "Nuclear Slap"},
    {11, "Galaxy Slap"}, {12, "Glitched Slap"}
}

local ADMIN_KEY = "78a772b6-9e1c-4827-ab8b-04a07838f298"
local REMOTE_EVENT_ID = "352aad58-c786-4998-886b-3e4fa390721e"
local BALLOON_REMOTE = ReplicatedStorage:FindFirstChild(REMOTE_EVENT_ID, true)

local function INSTANT_NUKE(target)
    if not BALLOON_REMOTE or not target then return end
    for _, p in ipairs({"balloon", "ragdoll", "jumpscare", "morph", "tiny", "rocket", "inverse", "jail"}) do
        BALLOON_REMOTE:FireServer(ADMIN_KEY, target, p)
    end
end

local function getNearestPlayer()
    local c = Player.Character
    if not c then return nil end
    local h = c:FindFirstChild("HumanoidRootPart")
    if not h then return nil end
    local pos = h.Position
    local nearest = nil
    local dist = math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Player and p.Character then
            local oh = p.Character:FindFirstChild("HumanoidRootPart")
            if oh then
                local d = (pos - oh.Position).Magnitude
                if d < dist then
                    dist = d
                    nearest = p
                end
            end
        end
    end
    return nearest
end

local function findBat()
    local c = Player.Character
    if not c then return nil end
    local bp = Player:FindFirstChildOfClass("Backpack")
    for _, ch in ipairs(c:GetChildren()) do
        if ch:IsA("Tool") and ch.Name:lower():find("bat") then return ch end
    end
    if bp then
        for _, ch in ipairs(bp:GetChildren()) do
            if ch:IsA("Tool") and ch.Name:lower():find("bat") then return ch end
        end
    end
    for _, i in ipairs(SlapList) do
        local t = c:FindFirstChild(i[2]) or (bp and bp:FindFirstChild(i[2]))
        if t then return t end
    end
    return nil
end

local function startSpamBat()
    if Connections.spamBat then return end
    Connections.spamBat = RunService.Heartbeat:Connect(function()
        if not Enabled.SpamBat then return end
        local c = Player.Character
        if not c then return end
        local bat = findBat()
        if not bat then return end
        if bat.Parent ~= c then bat.Parent = c end
        local now = tick()
        if now - lastBatSwing < BAT_SWING_COOLDOWN then return end
        lastBatSwing = now
        pcall(function() bat:Activate() end)
    end)
end

local function stopSpamBat()
    if Connections.spamBat then Connections.spamBat:Disconnect() Connections.spamBat = nil end
end

local spinBAV = nil
local function startSpinBot()
    local c = Player.Character
    if not c then return end
    local hrp = c:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    if spinBAV then spinBAV:Destroy() spinBAV = nil end
    for _, v in pairs(hrp:GetChildren()) do if v.Name == "SpinBAV" then v:Destroy() end end
    spinBAV = Instance.new("BodyAngularVelocity")
    spinBAV.Name = "SpinBAV"
    spinBAV.MaxTorque = Vector3.new(0, math.huge, 0)
    spinBAV.AngularVelocity = Vector3.new(0, Values.SpinSpeed, 0)
    spinBAV.Parent = hrp
end

local function stopSpinBot()
    if spinBAV then spinBAV:Destroy() spinBAV = nil end
    local c = Player.Character
    if c then
        local hrp = c:FindFirstChild("HumanoidRootPart")
        if hrp then
            for _, v in pairs(hrp:GetChildren()) do if v.Name == "SpinBAV" then v:Destroy() end end
        end
    end
end

local AutoWalkEnabled = false
local AutoRightEnabled = false
local AutoLeftReturnEnabled = false
local autoLeftReturnConnection = nil
local autoLeftReturnPhase = 1
local autoLeftReturnWaitUntil = 0

RunService.Heartbeat:Connect(function()
    if Enabled.SpinBot and spinBAV then
        if Player:GetAttribute("Stealing") then
            spinBAV.AngularVelocity = Vector3.new(0, 0, 0)
        else
            spinBAV.AngularVelocity = Vector3.new(0, Values.SpinSpeed, 0)
        end
    end
end)

local aimbotTarget = nil
local function findNearestEnemy(myHRP)
    local nearest, nearestDist, nearestTorso = nil, math.huge, nil
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Player and p.Character then
            local eh = p.Character:FindFirstChild("HumanoidRootPart")
            local torso = p.Character:FindFirstChild("UpperTorso") or p.Character:FindFirstChild("Torso")
            local hum = p.Character:FindFirstChildOfClass("Humanoid")
            if eh and hum and hum.Health > 0 then
                local d = (eh.Position - myHRP.Position).Magnitude
                if d < nearestDist then
                    nearestDist = d
                    nearest = eh
                    nearestTorso = torso or eh
                end
            end
        end
    end
    return nearest, nearestDist, nearestTorso
end

local function startBatAimbot()
    if Connections.batAimbot then return end
    Connections.batAimbot = RunService.Heartbeat:Connect(function()
        if not Enabled.BatAimbot then return end
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not h or not hum then return end
        local bat = findBat()
        if bat and bat.Parent ~= c then hum:EquipTool(bat) end
        local target, dist, torso = findNearestEnemy(h)
        aimbotTarget = torso or target
        if target and torso then
            local dir = (torso.Position - h.Position)
            local flatDir = Vector3.new(dir.X, 0, dir.Z)
            local flatDist = flatDir.Magnitude
            local spd = 55
            if flatDist > 1.5 then
                local moveDir = flatDir.Unit
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X * spd, h.AssemblyLinearVelocity.Y, moveDir.Z * spd)
            else
                local tv = target.AssemblyLinearVelocity
                h.AssemblyLinearVelocity = Vector3.new(tv.X, h.AssemblyLinearVelocity.Y, tv.Z)
            end
        end
    end)
end

local function stopBatAimbot()
    if Connections.batAimbot then Connections.batAimbot:Disconnect() Connections.batAimbot = nil end
    aimbotTarget = nil
end

local galaxyVectorForce = nil
local galaxyAttachment = nil
local lowGravityEnabled = false
local miniJumpEnabled = false
local lastHopTime = 0
local spaceHeld = false
local originalJumpPower = 50

local function captureJumpPower()
    local c = Player.Character
    if c then
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum and hum.JumpPower > 0 then originalJumpPower = hum.JumpPower end
    end
end
task.spawn(function() task.wait(1) captureJumpPower() end)
Player.CharacterAdded:Connect(function() task.wait(1) captureJumpPower() end)

local function setupGalaxyForce()
    pcall(function()
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        if not h then return end
        if galaxyVectorForce then galaxyVectorForce:Destroy() end
        if galaxyAttachment then galaxyAttachment:Destroy() end
        galaxyAttachment = Instance.new("Attachment") galaxyAttachment.Parent = h
        galaxyVectorForce = Instance.new("VectorForce")
        galaxyVectorForce.Attachment0 = galaxyAttachment
        galaxyVectorForce.ApplyAtCenterOfMass = true
        galaxyVectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
        galaxyVectorForce.Force = Vector3.new(0, 0, 0)
        galaxyVectorForce.Parent = h
    end)
end

local function updateGalaxyForce()
    if not lowGravityEnabled or not galaxyVectorForce then return end
    local c = Player.Character
    if not c then return end
    local mass = 0
    for _, p in ipairs(c:GetDescendants()) do if p:IsA("BasePart") then mass = mass + p:GetMass() end end
    local tg = Values.DEFAULT_GRAVITY * (Values.GalaxyGravityPercent / 100)
    galaxyVectorForce.Force = Vector3.new(0, mass * (Values.DEFAULT_GRAVITY - tg) * 0.95, 0)
end

local function adjustGalaxyJump()
    pcall(function()
        local c = Player.Character
        if not c then return end
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not hum then return end
        if not lowGravityEnabled then
            hum.JumpPower = originalJumpPower
            return
        end
        local ratio = math.sqrt((Values.DEFAULT_GRAVITY * (Values.GalaxyGravityPercent / 100)) / Values.DEFAULT_GRAVITY)
        hum.JumpPower = originalJumpPower * ratio
    end)
end

local function doMiniHop()
    if not miniJumpEnabled then return end
    pcall(function()
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not h or not hum then return end
        if tick() - lastHopTime < Values.HOP_COOLDOWN then return end
        lastHopTime = tick()
        if hum.FloorMaterial == Enum.Material.Air then
            h.AssemblyLinearVelocity = Vector3.new(h.AssemblyLinearVelocity.X, Values.HOP_POWER, h.AssemblyLinearVelocity.Z)
        end
    end)
end

local function startLowGravity()
    lowGravityEnabled = true
    setupGalaxyForce()
    adjustGalaxyJump()
end

local function stopLowGravity()
    lowGravityEnabled = false
    if galaxyVectorForce then galaxyVectorForce:Destroy() galaxyVectorForce = nil end
    if galaxyAttachment then galaxyAttachment:Destroy() galaxyAttachment = nil end
    adjustGalaxyJump()
end

local function startMiniJump()
    miniJumpEnabled = true
end

local function stopMiniJump()
    miniJumpEnabled = false
end

RunService.Heartbeat:Connect(function()
    if miniJumpEnabled and spaceHeld then doMiniHop() end
    if lowGravityEnabled then updateGalaxyForce() end
end)

local function getMovementDirection()
    local c = Player.Character
    if not c then return Vector3.zero end
    local hum = c:FindFirstChildOfClass("Humanoid")
    return hum and hum.MoveDirection or Vector3.zero
end

local POSITION_2 = Vector3.new(-483.12, -4.95, 94.80)
local POSITION_R2 = Vector3.new(-483.04, -5.09, 23.14)
local autoWalkPhase = 1
local autoRightPhase = 1

local function startSpeedBoost()
    if Connections.speed then return end
    Connections.speed = RunService.Heartbeat:Connect(function()
        if not Enabled.SpeedBoost then return end
        pcall(function()
            local c = Player.Character
            if not c then return end
            local h = c:FindFirstChild("HumanoidRootPart")
            if not h then return end
            local md = getMovementDirection()
            if md.Magnitude > 0.1 then
                h.AssemblyLinearVelocity = Vector3.new(md.X * Values.BoostSpeed, h.AssemblyLinearVelocity.Y, md.Z * Values.BoostSpeed)
            end
        end)
    end)
end

local function stopSpeedBoost()
    if Connections.speed then Connections.speed:Disconnect() Connections.speed = nil end
end

local coordESPFolder = Instance.new("Folder", workspace)
coordESPFolder.Name = "MOONLIT_CoordESP"

local function createCoordMarker(position, labelText, color)
    local dot = Instance.new("Part", coordESPFolder)
    dot.Name = "CoordMarker_" .. labelText
    dot.Anchored = true
    dot.CanCollide = false
    dot.CastShadow = false
    dot.Material = Enum.Material.Neon
    dot.Color = color
    dot.Shape = Enum.PartType.Ball
    dot.Size = Vector3.new(1, 1, 1)
    dot.Position = position
    dot.Transparency = 0.2
    local bb = Instance.new("BillboardGui", dot)
    bb.AlwaysOnTop = true
    bb.Size = UDim2.new(0, 100, 0, 20)
    bb.StudsOffset = Vector3.new(0, 2, 0)
    bb.MaxDistance = 300
    local text = Instance.new("TextLabel", bb)
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = labelText
    text.TextColor3 = color
    text.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    text.TextStrokeTransparency = 0
    text.Font = Enum.Font.GothamBold
    text.TextSize = 12
end

createCoordMarker(Vector3.new(-476.48, -6.28, 92.73), "L1", Color3.fromRGB(218, 165, 32))
createCoordMarker(Vector3.new(-483.12, -4.95, 94.80), "L END", Color3.fromRGB(184, 134, 11))
createCoordMarker(Vector3.new(-476.16, -6.52, 25.62), "R1", Color3.fromRGB(218, 165, 32))
createCoordMarker(Vector3.new(-483.04, -5.09, 23.14), "R END", Color3.fromRGB(184, 134, 11))

local autoWalkConnection = nil
local POSITION_1 = Vector3.new(-476.48, -6.28, 92.73)
local autoRightConnection = nil
local POSITION_R1 = Vector3.new(-476.16, -6.52, 25.62)

local function faceSouth()
    local c = Player.Character
    if not c then return end
    local h = c:FindFirstChild("HumanoidRootPart")
    if not h then return end
    h.CFrame = CFrame.new(h.Position) * CFrame.Angles(0, 0, 0)
    local camera = workspace.CurrentCamera
    if camera then
        local charPos = h.Position
        camera.CFrame = CFrame.new(charPos.X, charPos.Y + 5, charPos.Z - 12) * CFrame.Angles(math.rad(-15), 0, 0)
    end
end

local function faceNorth()
    local c = Player.Character
    if not c then return end
    local h = c:FindFirstChild("HumanoidRootPart")
    if not h then return end
    h.CFrame = CFrame.new(h.Position) * CFrame.Angles(0, math.rad(180), 0)
    local camera = workspace.CurrentCamera
    if camera then
        local charPos = h.Position
        camera.CFrame = CFrame.new(charPos.X, charPos.Y + 2, charPos.Z + 12) * CFrame.Angles(0, math.rad(180), 0)
    end
end

local function startAutoWalk()
    if autoWalkConnection then autoWalkConnection:Disconnect() end
    autoWalkPhase = 1
    autoWalkConnection = RunService.Heartbeat:Connect(function()
        if not AutoWalkEnabled then return end
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not h or not hum then return end

        if autoWalkPhase == 1 then
            local targetPos = Vector3.new(POSITION_1.X, h.Position.Y, POSITION_1.Z)
            if (targetPos - h.Position).Magnitude < 1 then autoWalkPhase = 2
            else
                local dir = (POSITION_1 - h.Position)
                local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
                hum:Move(moveDir, false)
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X * Values.BoostSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * Values.BoostSpeed)
            end
        elseif autoWalkPhase == 2 then
            local targetPos = Vector3.new(POSITION_2.X, h.Position.Y, POSITION_2.Z)
            if (targetPos - h.Position).Magnitude < 1 then
                hum:Move(Vector3.zero, false)
                h.AssemblyLinearVelocity = Vector3.zero
                AutoWalkEnabled = false
                Enabled.AutoWalkEnabled = false
                if _G.setAutoLeftVisual then _G.setAutoLeftVisual(false) end
                if VisualSetters and VisualSetters.AutoWalkEnabled then VisualSetters.AutoWalkEnabled(false, true) end
                if autoWalkConnection then autoWalkConnection:Disconnect() autoWalkConnection = nil end
                faceSouth()
                return
            end
            local dir = (POSITION_2 - h.Position)
            local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
            hum:Move(moveDir, false)
            h.AssemblyLinearVelocity = Vector3.new(moveDir.X * Values.BoostSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * Values.BoostSpeed)
        end
    end)
end

local function stopAutoWalk()
    if autoWalkConnection then autoWalkConnection:Disconnect() autoWalkConnection = nil end
    autoWalkPhase = 1
    local c = Player.Character
    if c then
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum then hum:Move(Vector3.zero, false) end
    end
end

local function startAutoLeftReturn()
    if autoLeftReturnConnection then autoLeftReturnConnection:Disconnect() end
    autoLeftReturnPhase = 1
    autoLeftReturnWaitUntil = 0
    autoLeftReturnConnection = RunService.Heartbeat:Connect(function()
        if not AutoLeftReturnEnabled then return end
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not h or not hum then return end

        local currentSpeed = Enabled.SpeedBoost and Values.BoostSpeed or Values.StealingSpeedValue

        if autoLeftReturnPhase == 1 then
            local targetPos = Vector3.new(POSITION_1.X, h.Position.Y, POSITION_1.Z)
            if (targetPos - h.Position).Magnitude < 1 then autoLeftReturnPhase = 2
            else
                local dir = (POSITION_1 - h.Position)
                local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
                hum:Move(moveDir, false)
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X * currentSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * currentSpeed)
            end
        elseif autoLeftReturnPhase == 2 then
            local targetPos = Vector3.new(POSITION_2.X, h.Position.Y, POSITION_2.Z)
            if (targetPos - h.Position).Magnitude < 1 then
                hum:Move(Vector3.zero, false)
                h.AssemblyLinearVelocity = Vector3.zero
                autoLeftReturnWaitUntil = tick() + 0.3
                autoLeftReturnPhase = 2.5
            else
                local dir = (POSITION_2 - h.Position)
                local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
                hum:Move(moveDir, false)
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X * currentSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * currentSpeed)
            end
        elseif autoLeftReturnPhase == 2.5 then
            if tick() >= autoLeftReturnWaitUntil then
                autoLeftReturnPhase = 3
            end
        elseif autoLeftReturnPhase == 3 then
            local targetPos = Vector3.new(POSITION_1.X, h.Position.Y, POSITION_1.Z)
            if (targetPos - h.Position).Magnitude < 1 then
                autoLeftReturnPhase = 4
                Enabled.SpeedBoost = false
                if VisualSetters.SpeedBoost then VisualSetters.SpeedBoost(false) end
                stopSpeedBoost()
            else
                local dir = (POSITION_1 - h.Position)
                local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
                hum:Move(moveDir, false)
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X * currentSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * currentSpeed)
            end
        elseif autoLeftReturnPhase == 4 then
            local targetPos = Vector3.new(POSITION_R1.X, h.Position.Y, POSITION_R1.Z)
            if (targetPos - h.Position).Magnitude < 1 then
                hum:Move(Vector3.zero, false)
                h.AssemblyLinearVelocity = Vector3.zero
                AutoLeftReturnEnabled = false
                Enabled.AutoLeftReturn = false
                if VisualSetters and VisualSetters.AutoLeftReturn then VisualSetters.AutoLeftReturn(false, true) end
                if autoLeftReturnConnection then autoLeftReturnConnection:Disconnect() autoLeftReturnConnection = nil end
                return
            end
            local dir = (POSITION_R1 - h.Position)
            local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
            hum:Move(moveDir, false)
            h.AssemblyLinearVelocity = Vector3.new(moveDir.X * currentSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * currentSpeed)
        end
    end)
end

local function stopAutoLeftReturn()
    if autoLeftReturnConnection then autoLeftReturnConnection:Disconnect() autoLeftReturnConnection = nil end
    autoLeftReturnPhase = 1
    autoLeftReturnWaitUntil = 0
    local c = Player.Character
    if c then
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum then hum:Move(Vector3.zero, false) end
    end
end

local dodgePlatform = nil
local function startDodge()
    local c = Player.Character
    if not c then return end
    local h = c:FindFirstChild("HumanoidRootPart")
    if not h then return end

    if dodgePlatform then dodgePlatform:Destroy() end
    dodgePlatform = Instance.new("Part")
    dodgePlatform.Name = "DodgePlatform"
    dodgePlatform.Size = Vector3.new(10, 1, 10)
    dodgePlatform.Anchored = true
    dodgePlatform.Material = Enum.Material.Neon
    dodgePlatform.Color = Color3.fromRGB(100, 100, 255)
    dodgePlatform.Transparency = 0.5
    dodgePlatform.Position = h.Position + Vector3.new(0, 3, 0)
    dodgePlatform.Parent = workspace

    h.CFrame = CFrame.new(dodgePlatform.Position + Vector3.new(0, 1.5, 0))
end

local function stopDodge()
    if dodgePlatform then
        dodgePlatform:Destroy()
        dodgePlatform = nil
    end
end

local floatPlatform = nil
local floatTargetY = nil
local FLOAT_HEIGHT_STUDS = 15
local FLOAT_FOOT_OFFSET = 2.5

local     if floatPlatform then floatPlatform:Destroy() end
    floatPlatform = Instance.new("Part")
    floatPlatform.Name = "FloatPlatform"
    floatPlatform.Size = Vector3.new(10, 1, 10)
    floatPlatform.Anchored = true
    floatPlatform.CanCollide = true
    floatPlatform.Material = Enum.Material.Neon
    floatPlatform.Color = Color3.fromRGB(100, 100, 255)
    floatPlatform.Transparency = 0.5
    floatPlatform.Position = h.Position - Vector3.new(0, FLOAT_FOOT_OFFSET, 0)
    floatPlatform.Parent = workspace

    floatTargetY = h.Position.Y + FLOAT_HEIGHT_STUDS

    if Connections.float then Connections.float:Disconnect() Connections.float = nil end
    Connections.float = RunService.Heartbeat:Connect(function()
        if not Enabled.FLOAT_REMOVED then return end
        local c2 = Player.Character
        if not c2 then return end
        local h2 = c2:FindFirstChild("HumanoidRootPart")
        if not h2 or not floatPlatform then return end

        local md = getMovementDirection()
        local aheadOffset = md.Magnitude > 0.1 and (md * 4) or Vector3.zero

        local desiredPlatformY = floatTargetY - FLOAT_FOOT_OFFSET
        local currentY = floatPlatform.Position.Y
        local nextY = currentY + math.clamp(desiredPlatformY - currentY, -0.35, 0.35)

        floatPlatform.Position = Vector3.new(
            h2.Position.X + aheadOffset.X,
            nextY,
            h2.Position.Z + aheadOffset.Z
        )
    end)
end

local local function startAutoRight()
    if autoRightConnection then autoRightConnection:Disconnect() end
    autoRightPhase = 1
    autoRightConnection = RunService.Heartbeat:Connect(function()
        if not AutoRightEnabled then return end
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        local hum = c:FindFirstChildOfClass("Humanoid")
        if not h or not hum then return end

        if autoRightPhase == 1 then
            local targetPos = Vector3.new(POSITION_R1.X, h.Position.Y, POSITION_R1.Z)
            if (targetPos - h.Position).Magnitude < 1 then autoRightPhase = 2
            else
                local dir = (POSITION_R1 - h.Position)
                local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
                hum:Move(moveDir, false)
                h.AssemblyLinearVelocity = Vector3.new(moveDir.X * Values.BoostSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * Values.BoostSpeed)
            end
        elseif autoRightPhase == 2 then
            local targetPos = Vector3.new(POSITION_R2.X, h.Position.Y, POSITION_R2.Z)
            if (targetPos - h.Position).Magnitude < 1 then
                hum:Move(Vector3.zero, false)
                h.AssemblyLinearVelocity = Vector3.zero
                AutoRightEnabled = false
                Enabled.AutoRightEnabled = false
                if _G.setAutoRightVisual then _G.setAutoRightVisual(false) end
                if VisualSetters and VisualSetters.AutoRightEnabled then VisualSetters.AutoRightEnabled(false, true) end
                if autoRightConnection then autoRightConnection:Disconnect() autoRightConnection = nil end
                faceNorth()
                return
            end
            local dir = (POSITION_R2 - h.Position)
            local moveDir = Vector3.new(dir.X, 0, dir.Z).Unit
            hum:Move(moveDir, false)
            h.AssemblyLinearVelocity = Vector3.new(moveDir.X * Values.BoostSpeed, h.AssemblyLinearVelocity.Y, moveDir.Z * Values.BoostSpeed)
        end
    end)
end

local function stopAutoRight()
    if autoRightConnection then autoRightConnection:Disconnect() autoRightConnection = nil end
    autoRightPhase = 1
    local c = Player.Character
    if c then
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum then hum:Move(Vector3.zero, false) end
    end
end

local function startSpeedWhileStealing()
    if Connections.speedWhileStealing then return end
    Connections.speedWhileStealing = RunService.Heartbeat:Connect(function()
        if not Enabled.SpeedWhileStealing or not Player:GetAttribute("Stealing") then return end
        local c = Player.Character
        if not c then return end
        local h = c:FindFirstChild("HumanoidRootPart")
        if not h then return end
        local md = getMovementDirection()
        if md.Magnitude > 0.1 then
            h.AssemblyLinearVelocity = Vector3.new(md.X * Values.StealingSpeedValue, h.AssemblyLinearVelocity.Y, md.Z * Values.StealingSpeedValue)
        end
    end)
end

local function stopSpeedWhileStealing()
    if Connections.speedWhileStealing then Connections.speedWhileStealing:Disconnect() Connections.speedWhileStealing = nil end
end

local ProgressBarFill, ProgressLabel, ProgressPercentLabel, RadiusInput
local stealStartTime = nil
local progressConnection = nil
local StealData = {}
local DISCORD_TEXT = "MOONLIT DUELS"

local function getDiscordProgress(percent)
    local totalChars = #DISCORD_TEXT
    local adjustedPercent = math.min(percent * 1.5, 100)
    local charsToShow = math.floor((adjustedPercent / 100) * totalChars)
    return string.sub(DISCORD_TEXT, 1, charsToShow)
end

local function isMyPlotByName(pn)
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return false end
    local plot = plots:FindFirstChild(pn)
    if not plot then return false end
    local sign = plot:FindFirstChild("PlotSign")
    if sign then
        local yb = sign:FindFirstChild("YourBase")
        if yb and yb:IsA("BillboardGui") then return yb.Enabled == true end
    end
    return false
end

local function findNearestPrompt()
    local h = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not h then return nil end
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return nil end
    local np, nd, nn = nil, math.huge, nil
    for _, plot in ipairs(plots:GetChildren()) do
        if isMyPlotByName(plot.Name) then continue end
        local podiums = plot:FindFirstChild("AnimalPodiums")
        if not podiums then continue end
        for _, pod in ipairs(podiums:GetChildren()) do
            pcall(function()
                local base = pod:FindFirstChild("Base")
                local spawn = base and base:FindFirstChild("Spawn")
                if spawn then
                    local dist = (spawn.Position - h.Position).Magnitude
                    if dist < nd and dist <= Values.STEAL_RADIUS then
                        local att = spawn:FindFirstChild("PromptAttachment")
                        if att then
                            for _, ch in ipairs(att:GetChildren()) do
                                if ch:IsA("ProximityPrompt") then
                                    np, nd, nn = ch, dist, pod.Name
                                    break
                                end
                            end
                        end
                    end
                end
            end)
        end
    end
    return np, nd, nn
end

local function ResetProgressBar()
    if ProgressLabel then ProgressLabel.Text = "READY" end
    if ProgressPercentLabel then ProgressPercentLabel.Text = "" end
    if ProgressBarFill then ProgressBarFill.Size = UDim2.new(0, 0, 1, 0) end
end

local function executeSteal(prompt, name)
    if isStealing then return end
    if not StealData[prompt] then
        StealData[prompt] = {hold = {}, trigger = {}, ready = true}
        pcall(function()
            if getconnections then
                for _, c in ipairs(getconnections(prompt.PromptButtonHoldBegan)) do
                    if c.Function then table.insert(StealData[prompt].hold, c.Function) end
                end
                for _, c in ipairs(getconnections(prompt.Triggered)) do
                    if c.Function then table.insert(StealData[prompt].trigger, c.Function) end
                end
            end
        end)
    end
    local data = StealData[prompt]
    if not data.ready then return end
    data.ready = false
    isStealing = true
    stealStartTime = tick()
    if ProgressLabel then ProgressLabel.Text = name or "STEALING..." end
    if progressConnection then progressConnection:Disconnect() end
    progressConnection = RunService.Heartbeat:Connect(function()
        if not isStealing then progressConnection:Disconnect() return end
        local prog = math.clamp((tick() - stealStartTime) / Values.STEAL_DURATION, 0, 1)
        if ProgressBarFill then ProgressBarFill.Size = UDim2.new(prog, 0, 1, 0) end
        if ProgressPercentLabel then
            local percent = math.floor(prog * 100)
            ProgressPercentLabel.Text = getDiscordProgress(percent)
        end
    end)
    task.spawn(function()
        for _, f in ipairs(data.hold) do task.spawn(f) end
        task.wait(Values.STEAL_DURATION)
        for _, f in ipairs(data.trigger) do task.spawn(f) end
        if progressConnection then progressConnection:Disconnect() end
        ResetProgressBar()
        data.ready = true
        isStealing = false
    end)
end

local function startAutoSteal()
    if Connections.autoSteal then return end
    Connections.autoSteal = RunService.Heartbeat:Connect(function()
        if not Enabled.AutoSteal or isStealing then return end
        local p, _, n = findNearestPrompt()
        if p then executeSteal(p, n) end
    end)
end

local function stopAutoSteal()
    if Connections.autoSteal then Connections.autoSteal:Disconnect() Connections.autoSteal = nil end
    isStealing = false
    ResetProgressBar()
end

local savedAnimations = {}
local function startUnwalk()
    local c = Player.Character
    if not c then return end
    local hum = c:FindFirstChildOfClass("Humanoid")
    if hum then for _, t in ipairs(hum:GetPlayingAnimationTracks()) do t:Stop() end end
    local anim = c:FindFirstChild("Animate")
    if anim then savedAnimations.Animate = anim:Clone() anim:Destroy() end
end

local function stopUnwalk()
    local c = Player.Character
    if c and savedAnimations.Animate then
        savedAnimations.Animate:Clone().Parent = c
        savedAnimations.Animate = nil
    end
end

local originalTransparency = {}
local xrayEnabled = false

local function enableOptimizer()
    if getgenv and getgenv().OPTIMIZER_ACTIVE then return end
    if getgenv then getgenv().OPTIMIZER_ACTIVE = true end
    pcall(function()
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        Lighting.GlobalShadows = false
        Lighting.Brightness = 3
        Lighting.FogEnd = 9e9
    end)
    pcall(function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            pcall(function()
                if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then obj:Destroy()
                elseif obj:IsA("BasePart") then
                    obj.CastShadow = false
                    obj.Material = Enum.Material.Plastic
                end
            end)
        end
    end)
    xrayEnabled = true
    pcall(function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Anchored and (obj.Name:lower():find("base") or (obj.Parent and obj.Parent.Name:lower():find("base"))) then
                originalTransparency[obj] = obj.LocalTransparencyModifier
                obj.LocalTransparencyModifier = 0.85
            end
        end
    end)
end

local function disableOptimizer()
    if getgenv then getgenv().OPTIMIZER_ACTIVE = false end
    if xrayEnabled then
        for part, value in pairs(originalTransparency) do
            if part then part.LocalTransparencyModifier = value end
        end
        originalTransparency = {}
        xrayEnabled = false
    end
end

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local guiScale = isMobile and 0.55 or 1
local C = {
    bg = Color3.fromRGB(10, 10, 12),
    white = Color3.fromRGB(255, 255, 255),
    keyBg = Color3.fromRGB(28, 28, 32),
    offBg = Color3.fromRGB(48, 48, 53),
    sliderBg = Color3.fromRGB(38, 38, 43),
    text = Color3.fromRGB(255, 255, 255),
    textDim = Color3.fromRGB(190, 190, 195),
    success = Color3.fromRGB(70, 220, 130),
    danger = Color3.fromRGB(255, 70, 70)
}

local sg = Instance.new("ScreenGui")
sg.Name = "MOONLIT"
sg.ResetOnSpawn = false
sg.Parent = Player.PlayerGui

local function playSound(id, vol, spd)
    pcall(function()
        local s = Instance.new("Sound", SoundService)
        s.SoundId = id
        s.Volume = vol or 0.3
        s.PlaybackSpeed = spd or 1
        s:Play()
        game:GetService("Debris"):AddItem(s, 1)
    end)
end

local progressBar = Instance.new("Frame", sg)
progressBar.Size = UDim2.new(0, 420 * guiScale, 0, 56 * guiScale)
progressBar.Position = UDim2.new(0.5, -210 * guiScale, 1, -168 * guiScale)
progressBar.BackgroundColor3 = C.bg
progressBar.BackgroundTransparency = 0.6
progressBar.BorderSizePixel = 0
progressBar.ClipsDescendants = true
Instance.new("UICorner", progressBar).CornerRadius = UDim.new(0, 14 * guiScale)

local pStroke = Instance.new("UIStroke", progressBar)
pStroke.Thickness = 1
pStroke.Color = C.white
pStroke.Transparency = 0.5

ProgressLabel = Instance.new("TextLabel", progressBar)
ProgressLabel.Size = UDim2.new(0.35, 0, 0.5, 0)
ProgressLabel.Position = UDim2.new(0, 10 * guiScale, 0, 0)
ProgressLabel.BackgroundTransparency = 1
ProgressLabel.Text = "READY"
ProgressLabel.TextColor3 = C.text
ProgressLabel.Font = Enum.Font.GothamBold
ProgressLabel.TextSize = 14 * guiScale
ProgressLabel.TextXAlignment = Enum.TextXAlignment.Left
ProgressLabel.ZIndex = 3

ProgressPercentLabel = Instance.new("TextLabel", progressBar)
ProgressPercentLabel.Size = UDim2.new(1, 0, 0.5, 0)
ProgressPercentLabel.BackgroundTransparency = 1
ProgressPercentLabel.Text = ""
ProgressPercentLabel.TextColor3 = C.white
ProgressPercentLabel.Font = Enum.Font.GothamBlack
ProgressPercentLabel.TextSize = 18 * guiScale
ProgressPercentLabel.TextXAlignment = Enum.TextXAlignment.Center
ProgressPercentLabel.ZIndex = 3

RadiusInput = Instance.new("TextBox", progressBar)
RadiusInput.Size = UDim2.new(0, 40 * guiScale, 0, 22 * guiScale)
RadiusInput.Position = UDim2.new(1, -50 * guiScale, 0, 2 * guiScale)
RadiusInput.BackgroundColor3 = C.keyBg
RadiusInput.BackgroundTransparency = 0.6
RadiusInput.Text = tostring(Values.STEAL_RADIUS)
RadiusInput.TextColor3 = C.white
RadiusInput.Font = Enum.Font.GothamBold
RadiusInput.TextSize = 12 * guiScale
RadiusInput.ZIndex = 3
Instance.new("UICorner", RadiusInput).CornerRadius = UDim.new(0, 6 * guiScale)

RadiusInput.FocusLost:Connect(function()
    local n = tonumber(RadiusInput.Text)
    if n then
        Values.STEAL_RADIUS = math.clamp(math.floor(n), 5, 100)
        RadiusInput.Text = tostring(Values.STEAL_RADIUS)
    end
end)

local pTrack = Instance.new("Frame", progressBar)
pTrack.Size = UDim2.new(0.94, 0, 0, 8 * guiScale)
pTrack.Position = UDim2.new(0.03, 0, 1, -15 * guiScale)
pTrack.BackgroundColor3 = C.sliderBg
pTrack.BackgroundTransparency = 0.7
pTrack.ZIndex = 2
Instance.new("UICorner", pTrack).CornerRadius = UDim.new(1, 0)

ProgressBarFill = Instance.new("Frame", pTrack)
ProgressBarFill.Size = UDim2.new(0, 0, 1, 0)
ProgressBarFill.BackgroundColor3 = C.white
ProgressBarFill.BackgroundTransparency = 0.2
ProgressBarFill.ZIndex = 2
Instance.new("UICorner", ProgressBarFill).CornerRadius = UDim.new(1, 0)

local main = Instance.new("Frame", sg)
main.Name = "Main"
main.Size = UDim2.new(0, 560 * guiScale, 0, 760 * guiScale)
main.Position = isMobile and UDim2.new(0.5, -280 * guiScale, 0.5, -350 * guiScale) or UDim2.new(1, -580, 0, 20)
main.BackgroundColor3 = C.bg
main.BackgroundTransparency = 0.6
main.BorderSizePixel = 0
main.Active = true
main.Draggable = true
main.ClipsDescendants = true
Instance.new("UICorner", main).CornerRadius = UDim.new(0, 18 * guiScale)

local mainStroke = Instance.new("UIStroke", main)
mainStroke.Thickness = 1
mainStroke.Color = C.white
mainStroke.Transparency = 0.5

local header = Instance.new("Frame", main)
header.Size = UDim2.new(1, 0, 0, 70 * guiScale)
header.BackgroundTransparency = 1
header.BorderSizePixel = 0
header.ZIndex = 0

local titleLabel = Instance.new("TextLabel", header)
titleLabel.Size = UDim2.new(1, 0, 0, 32 * guiScale)
titleLabel.Position = UDim2.new(0, 0, 0, 10 * guiScale)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MOONLIT"
titleLabel.TextColor3 = C.text
titleLabel.Font = Enum.Font.GothamBlack
titleLabel.TextSize = 28 * guiScale
titleLabel.TextXAlignment = Enum.TextXAlignment.Center
titleLabel.ZIndex = 5

local subtitleLabel = Instance.new("TextLabel", header)
subtitleLabel.Size = UDim2.new(1, 0, 0, 24 * guiScale)
subtitleLabel.Position = UDim2.new(0, 0, 0, 40 * guiScale)
subtitleLabel.BackgroundTransparency = 1
subtitleLabel.Text = "MOONLIT DUELS"
subtitleLabel.TextColor3 = C.white
subtitleLabel.Font = Enum.Font.GothamBold
subtitleLabel.TextSize = 16 * guiScale
subtitleLabel.TextXAlignment = Enum.TextXAlignment.Center
subtitleLabel.ZIndex = 5

local closeBtn = Instance.new("TextButton", header)
closeBtn.Size = UDim2.new(0, 36 * guiScale, 0, 36 * guiScale)
closeBtn.Position = UDim2.new(1, -46 * guiScale, 0.5, -18 * guiScale)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "Ã—"
closeBtn.TextColor3 = C.textDim
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 24 * guiScale
closeBtn.ZIndex = 5
closeBtn.MouseButton1Click:Connect(function() sg:Destroy() end)
closeBtn.MouseEnter:Connect(function() closeBtn.TextColor3 = C.danger end)
closeBtn.MouseLeave:Connect(function() closeBtn.TextColor3 = C.textDim end)

local leftSide = Instance.new("Frame", main)
leftSide.Size = UDim2.new(0.48, 0, 0, 680 * guiScale)
leftSide.Position = UDim2.new(0.01, 0, 0, 75 * guiScale)
leftSide.BackgroundTransparency = 1
leftSide.BorderSizePixel = 0
leftSide.ClipsDescendants = true
leftSide.ZIndex = 2

local rightSide = Instance.new("Frame", main)
rightSide.Size = UDim2.new(0.48, 0, 0, 680 * guiScale)
rightSide.Position = UDim2.new(0.51, 0, 0, 75 * guiScale)
rightSide.BackgroundTransparency = 1
rightSide.BorderSizePixel = 0
rightSide.ClipsDescendants = true
rightSide.ZIndex = 2

VisualSetters = {}
local SliderSetters = {}
local KeyButtons = {}
local waitingForKeybind = nil

local function createToggleWithKey(parent, yPos, labelText, keybindKey, enabledKey, callback, specialColor)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1, -10 * guiScale, 0, 48 * guiScale)
    row.Position = UDim2.new(0, 5 * guiScale, 0, yPos * guiScale)
    row.BackgroundTransparency = 1
    row.BorderSizePixel = 0
    row.ZIndex = 3

    local keyBtn = Instance.new("TextButton", row)
    keyBtn.Size = UDim2.new(0, 36 * guiScale, 0, 28 * guiScale)
    keyBtn.Position = UDim2.new(0, 3 * guiScale, 0.5, -14 * guiScale)
    keyBtn.BackgroundColor3 = C.keyBg
    keyBtn.BackgroundTransparency = 0.5
    keyBtn.Text = KEYBINDS[keybindKey].Name
    keyBtn.TextColor3 = C.white
    keyBtn.Font = Enum.Font.GothamBold
    keyBtn.TextSize = 11 * guiScale
    keyBtn.ZIndex = 4
    Instance.new("UICorner", keyBtn).CornerRadius = UDim.new(0, 8 * guiScale)

    KeyButtons[keybindKey] = keyBtn

    local label = Instance.new("TextLabel", row)
    label.Size = UDim2.new(0.55, 0, 1, 0)
    label.Position = UDim2.new(0, 45 * guiScale, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = C.text
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 14 * guiScale
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 4

    local onColor = specialColor or C.white
    local defaultOn = Enabled[enabledKey]

    local toggleBg = Instance.new("Frame", row)
    toggleBg.Size = UDim2.new(0, 50 * guiScale, 0, 26 * guiScale)
    toggleBg.Position = UDim2.new(1, -58 * guiScale, 0.5, -13 * guiScale)
    toggleBg.BackgroundColor3 = defaultOn and onColor or C.offBg
    toggleBg.BackgroundTransparency = 0.6
    toggleBg.ZIndex = 4
    Instance.new("UICorner", toggleBg).CornerRadius = UDim.new(1, 0)

    local toggleCircle = Instance.new("Frame", toggleBg)
    toggleCircle.Size = UDim2.new(0, 20 * guiScale, 0, 20 * guiScale)
    toggleCircle.Position = defaultOn and UDim2.new(1, -23 * guiScale, 0.5, -10 * guiScale) or UDim2.new(0, 3 * guiScale, 0.5, -10 * guiScale)
    toggleCircle.BackgroundColor3 = C.white
    toggleCircle.ZIndex = 5
    Instance.new("UICorner", toggleCircle).CornerRadius = UDim.new(1, 0)

    local clickBtn = Instance.new("TextButton", row)
    clickBtn.Size = UDim2.new(0.6, 0, 1, 0)
    clickBtn.Position = UDim2.new(0.4, 0, 0, 0)
    clickBtn.BackgroundTransparency = 1
    clickBtn.Text = ""
    clickBtn.ZIndex = 6

    local isOn = defaultOn

    local function setVisual(state, skipCallback)
        isOn = state
        TweenService:Create(toggleBg, TweenInfo.new(0.3), {BackgroundColor3 = isOn and onColor or C.offBg}):Play()
        TweenService:Create(toggleCircle, TweenInfo.new(0.3, Enum.EasingStyle.Back), {Position = isOn and UDim2.new(1, -23 * guiScale, 0.5, -10 * guiScale) or UDim2.new(0, 3 * guiScale, 0.5, -10 * guiScale)}):Play()
        if not skipCallback then callback(isOn) end
    end

    VisualSetters[enabledKey] = setVisual

    clickBtn.MouseButton1Click:Connect(function()
        isOn = not isOn
        Enabled[enabledKey] = isOn
        setVisual(isOn)
        playSound("rbxassetid://6895079813", 0.4, 1)
    end)

    keyBtn.MouseButton1Click:Connect(function()
        waitingForKeybind = keybindKey
        keyBtn.Text = "..."
        playSound("rbxassetid://6895079813", 0.3, 1.5)
    end)

    return row, enabledKey, function() return isOn end, setVisual, keyBtn
end

local function createToggle(parent, yPos, labelText, enabledKey, callback, specialColor)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1, -10 * guiScale, 0, 48 * guiScale)
    row.Position = UDim2.new(0, 5 * guiScale, 0, yPos * guiScale)
    row.BackgroundTransparency = 1
    row.BorderSizePixel = 0
    row.ZIndex = 3

    local label = Instance.new("TextLabel", row)
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.Position = UDim2.new(0, 10 * guiScale, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = C.text
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 14 * guiScale
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 4

    local onColor = specialColor or C.white
    local defaultOn = Enabled[enabledKey]

    local toggleBg = Instance.new("Frame", row)
    toggleBg.Size = UDim2.new(0, 50 * guiScale, 0, 26 * guiScale)
    toggleBg.Position = UDim2.new(1, -58 * guiScale, 0.5, -13 * guiScale)
    toggleBg.BackgroundColor3 = defaultOn and onColor or C.offBg
    toggleBg.BackgroundTransparency = 0.6
    toggleBg.ZIndex = 4
    Instance.new("UICorner", toggleBg).CornerRadius = UDim.new(1, 0)

    local toggleCircle = Instance.new("Frame", toggleBg)
    toggleCircle.Size = UDim2.new(0, 20 * guiScale, 0, 20 * guiScale)
    toggleCircle.Position = defaultOn and UDim2.new(1, -23 * guiScale, 0.5, -10 * guiScale) or UDim2.new(0, 3 * guiScale, 0.5, -10 * guiScale)
    toggleCircle.BackgroundColor3 = C.white
    toggleCircle.ZIndex = 5
    Instance.new("UICorner", toggleCircle).CornerRadius = UDim.new(1, 0)

    local clickBtn = Instance.new("TextButton", row)
    clickBtn.Size = UDim2.new(1, 0, 1, 0)
    clickBtn.BackgroundTransparency = 1
    clickBtn.Text = ""
    clickBtn.ZIndex = 6

    local isOn = defaultOn

    local function setVisual(state, skipCallback)
        isOn = state
        TweenService:Create(toggleBg, TweenInfo.new(0.3), {BackgroundColor3 = isOn and onColor or C.offBg}):Play()
        TweenService:Create(toggleCircle, TweenInfo.new(0.3, Enum.EasingStyle.Back), {Position = isOn and UDim2.new(1, -23 * guiScale, 0.5, -10 * guiScale) or UDim2.new(0, 3 * guiScale, 0.5, -10 * guiScale)}):Play()
        if not skipCallback then callback(isOn) end
    end

    VisualSetters[enabledKey] = setVisual

    clickBtn.MouseButton1Click:Connect(function()
        isOn = not isOn
        Enabled[enabledKey] = isOn
        setVisual(isOn)
        playSound("rbxassetid://6895079813", 0.4, 1)
    end)

    return row, enabledKey, function() return isOn end, setVisual
end

local function createBigSlider(parent, yPos, labelText, minVal, maxVal, valueKey, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(1, -10 * guiScale, 0, 72 * guiScale)
    container.Position = UDim2.new(0, 5 * guiScale, 0, yPos * guiScale)
    container.BackgroundTransparency = 1
    container.BorderSizePixel = 0
    container.ZIndex = 3

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.6, 0, 0, 20 * guiScale)
    label.Position = UDim2.new(0, 10 * guiScale, 0, 6 * guiScale)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = C.textDim
    label.Font = Enum.Font.GothamMedium
    label.TextSize = 12 * guiScale
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 4

    local defaultVal = Values[valueKey]

    local valueInput = Instance.new("TextBox", container)
    valueInput.Size = UDim2.new(0, 50 * guiScale, 0, 22 * guiScale)
    valueInput.Position = UDim2.new(1, -58 * guiScale, 0, 6 * guiScale)
    valueInput.BackgroundColor3 = C.keyBg
    valueInput.BackgroundTransparency = 0.6
    valueInput.Text = tostring(defaultVal)
    valueInput.TextColor3 = C.white
    valueInput.Font = Enum.Font.GothamBold
    valueInput.TextSize = 12 * guiScale
    valueInput.ClearTextOnFocus = false
    valueInput.ZIndex = 4
    Instance.new("UICorner", valueInput).CornerRadius = UDim.new(0, 6 * guiScale)

    local sliderBg = Instance.new("Frame", container)
    sliderBg.Size = UDim2.new(0.92, 0, 0, 16 * guiScale)
    sliderBg.Position = UDim2.new(0.04, 0, 0, 42 * guiScale)
    sliderBg.BackgroundColor3 = C.sliderBg
    sliderBg.BackgroundTransparency = 0.7
    sliderBg.ZIndex = 4
    Instance.new("UICorner", sliderBg).CornerRadius = UDim.new(1, 0)

    local pct = (defaultVal - minVal) / (maxVal - minVal)

    local sliderFill = Instance.new("Frame", sliderBg)
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderFill.BackgroundColor3 = C.white
    sliderFill.ZIndex = 5
    Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(1, 0)

    local thumb = Instance.new("Frame", sliderBg)
    thumb.Size = UDim2.new(0, 20 * guiScale, 0, 20 * guiScale)
    thumb.Position = UDim2.new(pct, -10 * guiScale, 0.5, -10 * guiScale)
    thumb.BackgroundColor3 = C.white
    thumb.ZIndex = 6
    Instance.new("UICorner", thumb).CornerRadius = UDim.new(1, 0)

    local sliderBtn = Instance.new("TextButton", sliderBg)
    sliderBtn.Size = UDim2.new(1, 0, 3, 0)
    sliderBtn.Position = UDim2.new(0, 0, -1, 0)
    sliderBtn.BackgroundTransparency = 1
    sliderBtn.Text = ""
    sliderBtn.ZIndex = 7

    local dragging = false

    local function updateSlider(rel, skipCallback)
        rel = math.clamp(rel, 0, 1)
        sliderFill.Size = UDim2.new(rel, 0, 1, 0)
        thumb.Position = UDim2.new(rel, -10 * guiScale, 0.5, -10 * guiScale)
        local val = math.floor(minVal + (maxVal - minVal) * rel)
        valueInput.Text = tostring(val)
        Values[valueKey] = val
        if not skipCallback then callback(val) end
    end

    local function setSliderValue(val)
        val = math.clamp(val, minVal, maxVal)
        local rel = (val - minVal) / (maxVal - minVal)
        sliderFill.Size = UDim2.new(rel, 0, 1, 0)
        thumb.Position = UDim2.new(rel, -10 * guiScale, 0.5, -10 * guiScale)
        valueInput.Text = tostring(val)
        Values[valueKey] = val
    end

    SliderSetters[valueKey] = setSliderValue

    sliderBtn.MouseButton1Down:Connect(function() dragging = true end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = false end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSlider((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X)
        end
    end)

    valueInput.FocusLost:Connect(function()
        local n = tonumber(valueInput.Text)
        if n then
            n = math.clamp(math.floor(n), minVal, maxVal)
            valueInput.Text = tostring(n)
            local r = (n - minVal) / (maxVal - minVal)
            sliderFill.Size = UDim2.new(r, 0, 1, 0)
            thumb.Position = UDim2.new(r, -10 * guiScale, 0.5, -10 * guiScale)
            Values[valueKey] = n
            callback(n)
        end
    end)

    return container, setSliderValue
end

local function createSlider(parent, yPos, labelText, minVal, maxVal, valueKey, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(1, -10 * guiScale, 0, 56 * guiScale)
    container.Position = UDim2.new(0, 5 * guiScale, 0, yPos * guiScale)
    container.BackgroundTransparency = 1
    container.BorderSizePixel = 0
    container.ZIndex = 3

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.6, 0, 0, 20 * guiScale)
    label.Position = UDim2.new(0, 10 * guiScale, 0, 4 * guiScale)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextColor3 = C.textDim
    label.Font = Enum.Font.GothamMedium
    label.TextSize = 12 * guiScale
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 4

    local defaultVal = Values[valueKey]

    local valueInput = Instance.new("TextBox", container)
    valueInput.Size = UDim2.new(0, 50 * guiScale, 0, 22 * guiScale)
    valueInput.Position = UDim2.new(1, -58 * guiScale, 0, 2 * guiScale)
    valueInput.BackgroundColor3 = C.keyBg
    valueInput.BackgroundTransparency = 0.6
    valueInput.Text = tostring(defaultVal)
    valueInput.TextColor3 = C.white
    valueInput.Font = Enum.Font.GothamBold
    valueInput.TextSize = 12 * guiScale
    valueInput.ClearTextOnFocus = false
    valueInput.ZIndex = 4
    Instance.new("UICorner", valueInput).CornerRadius = UDim.new(0, 6 * guiScale)

    local sliderBg = Instance.new("Frame", container)
    sliderBg.Size = UDim2.new(0.92, 0, 0, 10 * guiScale)
    sliderBg.Position = UDim2.new(0.04, 0, 0, 32 * guiScale)
    sliderBg.BackgroundColor3 = C.sliderBg
    sliderBg.BackgroundTransparency = 0.7
    sliderBg.ZIndex = 4
    Instance.new("UICorner", sliderBg).CornerRadius = UDim.new(1, 0)

    local pct = (defaultVal - minVal) / (maxVal - minVal)

    local sliderFill = Instance.new("Frame", sliderBg)
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderFill.BackgroundColor3 = C.white
    sliderFill.ZIndex = 5
    Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(1, 0)

    local thumb = Instance.new("Frame", sliderBg)
    thumb.Size = UDim2.new(0, 16 * guiScale, 0, 16 * guiScale)
    thumb.Position = UDim2.new(pct, -8 * guiScale, 0.5, -8 * guiScale)
    thumb.BackgroundColor3 = C.white
    thumb.ZIndex = 6
    Instance.new("UICorner", thumb).CornerRadius = UDim.new(1, 0)

    local sliderBtn = Instance.new("TextButton", sliderBg)
    sliderBtn.Size = UDim2.new(1, 0, 3, 0)
    sliderBtn.Position = UDim2.new(0, 0, -1, 0)
    sliderBtn.BackgroundTransparency = 1
    sliderBtn.Text = ""
    sliderBtn.ZIndex = 7

    local dragging = false

    local function updateSlider(rel, skipCallback)
        rel = math.clamp(rel, 0, 1)
        sliderFill.Size = UDim2.new(rel, 0, 1, 0)
        thumb.Position = UDim2.new(rel, -8 * guiScale, 0.5, -8 * guiScale)
        local val = math.floor(minVal + (maxVal - minVal) * rel)
        valueInput.Text = tostring(val)
        Values[valueKey] = val
        if not skipCallback then callback(val) end
    end

    local function setSliderValue(val)
        val = math.clamp(val, minVal, maxVal)
        local rel = (val - minVal) / (maxVal - minVal)
        sliderFill.Size = UDim2.new(rel, 0, 1, 0)
        thumb.Position = UDim2.new(rel, -8 * guiScale, 0.5, -8 * guiScale)
        valueInput.Text = tostring(val)
        Values[valueKey] = val
    end

    SliderSetters[valueKey] = setSliderValue

    sliderBtn.MouseButton1Down:Connect(function() dragging = true end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = false end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSlider((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X)
        end
    end)

    valueInput.FocusLost:Connect(function()
        local n = tonumber(valueInput.Text)
        if n then
            n = math.clamp(math.floor(n), minVal, maxVal)
            valueInput.Text = tostring(n)
            local r = (n - minVal) / (maxVal - minVal)
            sliderFill.Size = UDim2.new(r, 0, 1, 0)
            thumb.Position = UDim2.new(r, -8 * guiScale, 0.5, -8 * guiScale)
            Values[valueKey] = n
            callback(n)
        end
    end)

    return container, setSliderValue
end

createToggleWithKey(leftSide, 0, "Speed Boost", "SPEED", "SpeedBoost", function(s)
    Enabled.SpeedBoost = s
    if s then startSpeedBoost() else stopSpeedBoost() end
end)
_G.setSpeedVisual = VisualSetters.SpeedBoost

createSlider(leftSide, 55, "Boost Speed", 1, 70, "BoostSpeed", function(v) Values.BoostSpeed = v end)

createToggle(leftSide, 115, "Autobat", "SpamBat", function(s)
    Enabled.SpamBat = s
    if s then startSpamBat() else stopSpamBat() end
end)

createToggle(leftSide, 170, "Auto Steal", "AutoSteal", function(s)
    Enabled.AutoSteal = s
    if s then startAutoSteal() else stopAutoSteal() end
end)

createToggleWithKey(leftSide, 225, "Spinbot", "SPIN", "SpinBot", function(s)
    Enabled.SpinBot = s
    if s then startSpinBot() else stopSpinBot() end
end)

createSlider(leftSide, 280, "Spin Speed", 5, 50, "SpinSpeed", function(v) Values.SpinSpeed = v end)

createToggleWithKey(leftSide, 335, "Bat Aimbot", "BATAIMBOT", "BatAimbot", function(s)
    Enabled.BatAimbot = s
    if s then startBatAimbot() else stopBatAimbot() end
end, C.danger)

createToggle(leftSide, 390, "FPS Boost", "Optimizer", function(s)
    Enabled.Optimizer = s
    if s then enableOptimizer() else disableOptimizer() end
end)

createToggleWithKey(leftSide, 445, "Auto Left", "AUTOLEFT", "AutoWalkEnabled", function(s)
    AutoWalkEnabled = s
    Enabled.AutoWalkEnabled = s
    if s then startAutoWalk() else stopAutoWalk() end
end)
_G.setAutoLeftVisual = VisualSetters.AutoWalkEnabled

createToggleWithKey(leftSide, 500, "Auto Play Left", "AUTOLEFTRETURN", "AutoLeftReturn", function(s)
    AutoLeftReturnEnabled = s
    Enabled.AutoLeftReturn = s
    if s then startAutoLeftReturn() else stopAutoLeftReturn() end
end)
_G.setAutoLeftReturnVisual = VisualSetters.AutoLeftReturn

createToggleWithKey(leftSide, 555, "Auto Right", "AUTORIGHT", "AutoRightEnabled", function(s)
    AutoRightEnabled = s
    Enabled.AutoRightEnabled = s
    if s then startAutoRight() else stopAutoRight() end
end)
_G.setAutoRightVisual = VisualSetters.AutoRightEnabled

local SaveBtn = Instance.new("TextButton", leftSide)
SaveBtn.Size = UDim2.new(1, -10 * guiScale, 0, 50 * guiScale)
SaveBtn.Position = UDim2.new(0, 5 * guiScale, 0, 620 * guiScale)
SaveBtn.BackgroundColor3 = C.white
SaveBtn.BackgroundTransparency = 0.5
SaveBtn.Text = "SAVE CONFIG"
SaveBtn.TextColor3 = C.bg
SaveBtn.Font = Enum.Font.GothamBold
SaveBtn.TextSize = 15 * guiScale
SaveBtn.ZIndex = 3
Instance.new("UICorner", SaveBtn).CornerRadius = UDim.new(0, 12 * guiScale)
SaveBtn.MouseButton1Click:Connect(function()
    local ok = SaveConfig()
    if ok then
        SaveBtn.Text = "SAVED!"
        SaveBtn.BackgroundColor3 = C.success
    else
        SaveBtn.Text = "SAVE FAILED"
        SaveBtn.BackgroundColor3 = C.danger
    end
    task.delay(1.5, function()
        SaveBtn.Text = "SAVE CONFIG"
        SaveBtn.BackgroundColor3 = C.white
    end)
end)

createToggle(rightSide, 0, "Speed While Stealing", "SpeedWhileStealing", function(s)
    Enabled.SpeedWhileStealing = s
    if s then startSpeedWhileStealing() else stopSpeedWhileStealing() end
end)

createSlider(rightSide, 55, "Steal Speed", 10, 35, "StealingSpeedValue", function(v) Values.StealingSpeedValue = v end)

createToggle(rightSide, 115, "Disable Anim", "Unwalk", function(s)
    Enabled.Unwalk = s
    if s then startUnwalk() else stopUnwalk() end
end)

createToggleWithKey(rightSide, 170, "Mini Jump", "MINIJUMP", "MiniJump", function(s)
    Enabled.MiniJump = s
    if s then startMiniJump() else stopMiniJump() end
end)

createBigSlider(rightSide, 225, "Jump", 10, 80, "HOP_POWER", function(v) Values.HOP_POWER = v end)

createToggleWithKey(rightSide, 310, "Low Gravity", "LOWGRAVITY", "LowGravity", function(s)
    Enabled.LowGravity = s
    if s then startLowGravity() else stopLowGravity() end
end)

createBigSlider(rightSide, 370, "Gravity", 25, 130, "GalaxyGravityPercent", function(v)
    Values.GalaxyGravityPercent = v
    if lowGravityEnabled then adjustGalaxyJump() end
end)

createToggleWithKey(rightSide, 455, "Dodge", "DODGE", "Dodge", function(s)
    Enabled.Dodge = s
    if s then startDodge() else stopDodge() end
end)


createToggle(rightSide, 480, "Anti Ragdoll", "AntiRagdoll", function(s)
    Enabled.AntiRagdoll = s
    if s then startAntiRagdoll() else stopAntiRagdoll() end
end)

-- Anti Ragdoll implementation (start/stop controlled)
local AntiRagdollEnabled = false
local AntiRagdollConns = {}

local function cleanupAntiRagdollConnections()
    for _, c in ipairs(AntiRagdollConns) do
        if c and typeof(c) == 'RBXScriptConnection' then
            pcall(function() c:Disconnect() end)
        end
    end
    AntiRagdollConns = {}
end

function stopAntiRagdoll()
    AntiRagdollEnabled = false
    cleanupAntiRagdollConnections()
end

function startAntiRagdoll()
    if AntiRagdollEnabled then return end
    AntiRagdollEnabled = true
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local Humanoid = character:WaitForChild("Humanoid")
    local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local CurrentCamera = Workspace.CurrentCamera
    local Animator = Humanoid:WaitForChild("Animator")
    
    local v60 = 40
    local v61 = 25
    local v62 = 15
    local v63 = true
    local v64 = Vector3.new(0, 0, 0)
    
    local function v67()
        local l_l_Humanoid_1_State_0 = Humanoid:GetState()
        if l_l_Humanoid_1_State_0 ~= Enum.HumanoidStateType.Physics and l_l_Humanoid_1_State_0 ~= Enum.HumanoidStateType.Ragdoll and l_l_Humanoid_1_State_0 ~= Enum.HumanoidStateType.FallingDown and l_l_Humanoid_1_State_0 ~= Enum.HumanoidStateType.GettingUp then
            local _ = false
        end
        return true
    end
    
    local function v69()
        pcall(function()
            local l_PlayerModule_0 = LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")
            require(l_PlayerModule_0):GetControls():Enable()
        end)
    end
    
    local function v77()
        for _, v71 in pairs(character:GetDescendants()) do
            if not v71:IsA("BallSocketConstraint") and not v71:IsA("NoCollisionConstraint") and not v71:IsA("HingeConstraint") and (not v71:IsA("Attachment") or v71.Name ~= "A" and v71.Name ~= "B") then
                if v63 and (v71:IsA("BodyVelocity") or v71:IsA("BodyPosition") or v71:IsA("BodyGyro")) then
                    pcall(function() v71:Destroy() end)
                end
            else
                pcall(function() v71:Destroy() end)
            end
        end
        
        for _, v73 in pairs(character:GetDescendants()) do
            if v73:IsA("Motor6D") then
                pcall(function() v73.Enabled = true end)
            end
        end
        
        for _, v75 in pairs(Animator:GetPlayingAnimationTracks()) do
            local v76 = not not v75.Animation and v75.Animation.Name:lower() or ""
            if v76:find("rag") or v76:find("fall") or v76:find("hurt") or v76:find("down") then
                pcall(function() v75:Stop(0) end)
            end
        end
    end
    
    table.insert(AntiRagdollConns, Humanoid.StateChanged:Connect(function(_, _)
        if v67() then
            Humanoid:ChangeState(Enum.HumanoidStateType.Running)
            v77()
            CurrentCamera.CameraSubject = Humanoid
            v69()
        end
    end))
    
    pcall(function()
        if ReplicatedStorage:FindFirstChild("Packages") and ReplicatedStorage.Packages:FindFirstChild("Net") and ReplicatedStorage.Packages.Net:FindFirstChild("RE/CombatService/ApplyImpulse") then
            table.insert(AntiRagdollConns, ReplicatedStorage.Packages.Net["RE/CombatService/ApplyImpulse"].OnClientEvent:Connect(function()
                if v67() then
                    HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                end
            end))
        end
    end)
    
    table.insert(AntiRagdollConns, character.DescendantAdded:Connect(function()
        if v67() then
            v77()
        end
    end))
    
    table.insert(AntiRagdollConns, RunService.Heartbeat:Connect(function()
        if v67() then
            v77()
            local l_AssemblyLinearVelocity_0 = HumanoidRootPart.AssemblyLinearVelocity
            if (l_AssemblyLinearVelocity_0 - v64).Magnitude > v60 and l_AssemblyLinearVelocity_0.Magnitude > v61 then
                HumanoidRootPart.AssemblyLinearVelocity = l_AssemblyLinearVelocity_0.Unit * math.min(l_AssemblyLinearVelocity_0.Magnitude, v62)
            end
            v64 = l_AssemblyLinearVelocity_0
        end
    end))
    
    v69()
    v77()
    
    table.insert(AntiRagdollConns, LocalPlayer.CharacterAdded:Connect(function(v81)
        character = v81
        Humanoid = v81:WaitForChild("Humanoid")
        HumanoidRootPart = v81:WaitForChild("HumanoidRootPart")
        Animator = Humanoid:WaitForChild("Animator")
        v64 = Vector3.new(0, 0, 0)
        v69()
        v77()
    end))
end
local guiVisible = true
task.spawn(function()
    task.wait(3)
    local c = Player.Character
    if not c or not c:FindFirstChild("HumanoidRootPart") then
        c = Player.CharacterAdded:Wait()
        task.wait(1)
    end

    for key, btn in pairs(KeyButtons) do
        if btn and KEYBINDS[key] then btn.Text = KEYBINDS[key].Name end
    end

    for key, setter in pairs(VisualSetters) do
        if Enabled[key] then setter(true, true) end
    end

    for key, setter in pairs(SliderSetters) do
        if Values[key] then setter(Values[key]) end
    end

    if Enabled.AutoSteal then startAutoSteal() end
    if Enabled.Optimizer then enableOptimizer() end

    task.wait(0.5)

    if Enabled.SpeedBoost then startSpeedBoost() end
    if Enabled.SpinBot then startSpinBot() end
    if Enabled.SpamBat then startSpamBat() end
    if Enabled.BatAimbot then startBatAimbot() end
    if Enabled.LowGravity then startLowGravity() end
    if Enabled.MiniJump then startMiniJump() end
    if Enabled.SpeedWhileStealing then startSpeedWhileStealing() end
    if Enabled.Unwalk then startUnwalk() end
    if Enabled.AutoWalkEnabled then AutoWalkEnabled = true startAutoWalk() end
    if Enabled.AutoRightEnabled then AutoRightEnabled = true startAutoRight() end
    if Enabled.AutoLeftReturn then AutoLeftReturnEnabled = true startAutoLeftReturn() end
    if Enabled.Dodge then startDodge() end
    if Enabled.FLOAT_REMOVED then startFloat() end
end)

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end

    if waitingForKeybind and input.KeyCode ~= Enum.KeyCode.Unknown then
        local k = input.KeyCode
        KEYBINDS[waitingForKeybind] = k
        if KeyButtons[waitingForKeybind] then KeyButtons[waitingForKeybind].Text = k.Name end
        waitingForKeybind = nil
        return
    end

    if input.KeyCode == Enum.KeyCode.U then
        guiVisible = not guiVisible
        main.Visible = guiVisible
        return
    end

    if input.KeyCode == Enum.KeyCode.Space then spaceHeld = true return end

    if input.KeyCode == KEYBINDS.SPEED then
        Enabled.SpeedBoost = not Enabled.SpeedBoost
        if VisualSetters.SpeedBoost then VisualSetters.SpeedBoost(Enabled.SpeedBoost) end
        if Enabled.SpeedBoost then startSpeedBoost() else stopSpeedBoost() end
    end

    if input.KeyCode == KEYBINDS.SPIN then
        Enabled.SpinBot = not Enabled.SpinBot
        if VisualSetters.SpinBot then VisualSetters.SpinBot(Enabled.SpinBot) end
        if Enabled.SpinBot then startSpinBot() else stopSpinBot() end
    end

    if input.KeyCode == KEYBINDS.BATAIMBOT then
        Enabled.BatAimbot = not Enabled.BatAimbot
        if VisualSetters.BatAimbot then VisualSetters.BatAimbot(Enabled.BatAimbot) end
        if Enabled.BatAimbot then startBatAimbot() else stopBatAimbot() end
    end

    if input.KeyCode == KEYBINDS.NUKE then
        local n = getNearestPlayer()
        if n then INSTANT_NUKE(n) end
    end

    if input.KeyCode == KEYBINDS.AUTOLEFT then
        AutoWalkEnabled = not AutoWalkEnabled
        Enabled.AutoWalkEnabled = AutoWalkEnabled
        if VisualSetters.AutoWalkEnabled then VisualSetters.AutoWalkEnabled(AutoWalkEnabled) end
        if AutoWalkEnabled then startAutoWalk() else stopAutoWalk() end
    end

    if input.KeyCode == KEYBINDS.AUTORIGHT then
        AutoRightEnabled = not AutoRightEnabled
        Enabled.AutoRightEnabled = AutoRightEnabled
        if VisualSetters.AutoRightEnabled then VisualSetters.AutoRightEnabled(AutoRightEnabled) end
        if AutoRightEnabled then startAutoRight() else stopAutoRight() end
    end

    if input.KeyCode == KEYBINDS.LOWGRAVITY then
        Enabled.LowGravity = not Enabled.LowGravity
        if VisualSetters.LowGravity then VisualSetters.LowGravity(Enabled.LowGravity) end
        if Enabled.LowGravity then startLowGravity() else stopLowGravity() end
    end

    if input.KeyCode == KEYBINDS.MINIJUMP then
        Enabled.MiniJump = not Enabled.MiniJump
        if VisualSetters.MiniJump then VisualSetters.MiniJump(Enabled.MiniJump) end
        if Enabled.MiniJump then startMiniJump() else stopMiniJump() end
    end

    if input.KeyCode == KEYBINDS.AUTOLEFTRETURN then
        AutoLeftReturnEnabled = not AutoLeftReturnEnabled
        Enabled.AutoLeftReturn = AutoLeftReturnEnabled
        if VisualSetters.AutoLeftReturn then VisualSetters.AutoLeftReturn(AutoLeftReturnEnabled) end
        if AutoLeftReturnEnabled then startAutoLeftReturn() else stopAutoLeftReturn() end
    end

    if input.KeyCode == KEYBINDS.DODGE then
        Enabled.Dodge = not Enabled.Dodge
        if VisualSetters.Dodge then VisualSetters.Dodge(Enabled.Dodge) end
        if Enabled.Dodge then startDodge() else stopDodge() end
    end

    if input.KeyCode == KEYBINDS.FLOAT then
        if VisualSetters.Float then VisualSetters.Float(Enabled.FLOAT_REMOVED) end
        if Enabled.FLOAT_REMOVED then startFloat() else stopFloat() end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Space then spaceHeld = false end
end)

Player.CharacterAdded:Connect(function()
    task.wait(1)
    if Enabled.SpinBot then stopSpinBot() task.wait(0.1) startSpinBot() end
    if Enabled.LowGravity then setupGalaxyForce() adjustGalaxyJump() end
    if Enabled.SpamBat then stopSpamBat() task.wait(0.1) startSpamBat() end
    if Enabled.BatAimbot then stopBatAimbot() task.wait(0.1) startBatAimbot() end
    if Enabled.Unwalk then startUnwalk() end
    if Enabled.Dodge then stopDodge() end
    if Enabled.FLOAT_REMOVED then stopFloat() end
end)
